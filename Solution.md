# Тестовое задание
Разработать архитектуру приложения и описать алгоритм проведения сделки.

Контекст:
Cервис обмена валют.
Курсы обмена валютных пар предоставляются брокерами по средством API.
Курс меняется каждые 10 секунд, у каждого брокера свое рабочее время (cut-off time).
Для каждого брокера сервис может установить индивидуальную наценку
Брокеров может быть неограниченное количество.

Use-case:
Пользователь запрашивает сделку по валютной паре.
Сервис предоставляет лучшую возможную сделку как для клиента, так и для сервиса (минимальная сумма при максимальной наценке).
После чего клиент должен принять условия, если клиент не принимает условия, сделка аннулируется через оставшиеся секунды.

Реализовать ввиде 2 диаграм.
Организация самого приложения
SQL диаграмма устройство БД или flow chart

⸻
## Таблицы
#### Диаграмма основных таблиц БД - https://dbdiagram.io/d/currency-exchange-service-687d3a0df413ba3508c2ac05
- `broker` - информация о брокерах (id, markup, статус, используемые валютные пары, лимиты, макс/мин сумма операции и т.д.)
- `broker_schedule`описывает расписание работы брокеров (по дням недели, времени, возможно добавление колонок типа regular_days_off (например, 1 января), additional_working_days (рабочие "выходные"), additional_days_off, если есть такая необходимость и это отражает специфику работы броккеров).
- `broker_api_config` - креды, ключи, ендпоинты и доступы.
- `exchange_rate` - курсы, полученные от брокеров.
- `quote` - предварительное намерение/предложение о сделке.
- `deal` - зафиксированные сделки.
- `deal_log` - лог изменений по сделке.

---

## Получение курсов брокеров
### Очередь
1. Планировщик (scheduler) каждые 10 сек кладет задачи в очередь.
2. Воркер `BrokerRateFetcherWorker` обрабатывает задачи:
    - Проверяет доступность брокера (`BrokerAvailabilityService` - вычисляет режимы и время работы с учетом всех заданных конфигов и возвращает в методе isAvailable  true/false)
    - Делает запрос к API
    - `RateResolver` - вычисляет `final_rate = raw_rate + markup` исходя из заданных конфигов.
    - Сохраняет или обновляет `exchange_rate` с `expires_at = now + 10 секунд`
    - Рейты, которые не были обновлены или брокер которых был недоступен - помечаются как inactive.
    - Failover: при ошибке - сообщение уходит в DLQ (для ручной обработки и/или сбора аналитики)
    - Можно использовать RateLimiter для контроля вызова API брокеров, чтобы не выбить лимиты по кол-ву запросов.
---

#### Валидация и безопасность

#### При получении курса:
- Проверка:
    - Валидности валютной пары и суммы

#### При подтверждении сделки:
- Quote:
    - Существует и находится в нужном статусе, не была использована.
    - Не истекла (`expires_at > now`)
    - Принадлежит текущему пользователю
- Идемпотентность:
    - Redis-лок по `deal_id` или флаг в БД

---

## Quote-логика
#### Flowchart основных процессов - https://raw.githubusercontent.com/natalsem/smgr_test/refs/heads/main/ExchangeService_Flow.svg

### Генерация:
1. Фильтрация `exchange_rate` по: `base_currency`, `quote_currency`, `expires_at > now()`, `is_active`.
    и сортировка для выбора одной записи с лучшим соотношением для наценка сервиса/цена для клиента `final_rate ASC, markup DESC`
3. Генерация quote:
    - UUID + HMAC-подпись
    - Сохраняется в:
        - Redis: `quote:{uuid}`
        - БД: `quote` (для аудита и аналитики)
    - TTL: 10 секунд
    - На фронт возвращаем `quote_id`, `ttl`, запускается таймер по TTL. 
    - Если TTL истек - кнопка оформления сделки блокируется. Пользователя просят инициировать новый запрос.

    
### Ретрай-логика:
- Повтор через N секунд
- Максимум попыток: Х
- Далее - логгирование ошибки

---

## Оформление сделки
При нажатии подтверждения "Exchange":
1. Фронт отправляет `quote_id` на бэкенд.
2. Бэкенд
- проверяет, что квота валида;
- что квота принадлежит тому же пользователю, от которого получили запрос (проверка user_id, session_id);
- (опционально) что курс акутален (перепроверяем `expires_at` по `exchange_rate`);
- Помещает deal_id в очередь Redis'a. 
- Запись о сделке создается в таблице deal:
    - Статус `pending`, `is_active = false`, проставление `converted_at`
    - Записываем сумму, валюту, курс, брокера, expires_at, created_at.
---

## Обработка сделки (воркер `DealMessageProcessor`)
1. Получает сообщение `deal_id`, проверяет, не была ли уже обработана сделка.
2. Ставит Redis-лок `deal_lock_{deal_id}` (TTL = N сек)
3. Открывает транзакцию SELECT FOR UPDATE по `deal_id`
5. Проверяет:
    - `status = pending`
    - `now < expires_at`
6. Вызывает API брокера для совершения сделки.
7. Обновляет статус:
    - `confirmed` + `confirmed_at` или
    - `failed` + причина
8. Логирует все в `deal_log`
9. Освобождаем deal_lock_{deal_id} (или просто TTL сам истечет).

---

## Поддерживающие процессы
- Воркер/cron:
    - Переводит просроченные сделки в `expired`
    - Чистит Redis от quote с истекшим TTL
    - Очистка старых записей в БД - таблицы`exchange_rate`, `quote`, `deal_log`
- Мониторинг:
    - Метрики, кол-во ошибок
    - Интеграция с Grafana, Sentry и пр.

---

## Возможности расширения, не описанные в данном решении
- Админка для управления конфигами по брокерам, просмотра таблиц сделок, рейтов и пр.
- Сущность юзера и ЛК юзера - история сделок, избранные валютные пары (например, для возможности для quick order или reorder).
